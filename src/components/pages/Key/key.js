const codeExampleFirst = `
        const numbers = [1, 2, 3, 4, 5];
        const listItems = numbers.map((number) =>
            <li key={number.toString()}>
                {number}
            </li>
        );
    `
const codeExampleSecond = `
        const todoItems = todos.map((todo) =>
            <li key={todo.id}>
                {todo.text}
            </li>
        );

`

const Key = () =>{
    return(
        <div className='content'>
            <h2 className='content_header'>Ключи</h2>
            <span>Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:</span>
            <pre>
                <code>{codeExampleFirst}</code>
            </pre>
            <span>Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи:</span>
            <pre>
                <code>{codeExampleSecond}</code>
            </pre>
            <span>Ключи нужно определять непосредственно внутри массивов.</span>
            <span>Если не указать ключи, в консоли увидим сообщение: Warning: Each child in an array or iterator should have a unique “key” prop.</span>
            <span>Ключи оптимизируют работу с элементами массивов, уменьшают количество ненужных удалений и созданий элементов.</span>
            <span>Без key механизм reconciliation сверяет компоненты попарно между текущим и новым VDOM. Из-за этого может происходить большое количество лишних перерисовок интерфейса, что замедляет работу приложения.</span>
            <span>Добавляя key, вы помогаете механизму reconciliation тем, что с key он сверяет не попарно, а ищет компоненты с тем же key (тег / имя компонента при этом учитывается) — это уменьшает количество перерисовок интерфейса. Обновлены/добавлены будут только те элементы, которые были изменены/не встречались в предыдущем дереве.</span>
            <span>Следите, чтобы не появлялись дублирующие key, при переключении отображения у новых данных не совпадали ключи. Это может привести к нежелательным сайд-эффектам, таким как анимации, или некорректной логике поведения элемента.</span>
            <span>key и ref — специальные props. Они недоступны в компоненте, их нет в child.props. Можно получить доступ в родителе через child.key, но реальных областей применения для этого практически нет. Если в дочерних компонентах нужен key — правильным решением будет задублировать в prop id, например.</span>
        </div>
    )
}

export default Key;